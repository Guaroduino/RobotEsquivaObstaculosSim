<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Simulación Matter.js Cenital</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #222;
    }
    #sim {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #222;
    }
  </style>
</head>
<body>
  <div style="position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(34,34,34,0.9); padding: 10px; border-radius: 8px; color: #fff; font-family: sans-serif;">
    <label>Offset X (frente): <input id="sliderX" type="range" min="0" max="100" value="25" step="1"> <span id="valX"></span> mm</label><br>
    <label>Offset Y (lateral): <input id="sliderY" type="range" min="0" max="100" value="63" step="1"> <span id="valY"></span> mm</label><br>
    <hr style="border: 1px solid #444; margin: 8px 0;">
    <label>Sensor X (frente): <input id="sliderSensorX" type="range" min="0" max="120" value="90" step="1"> <span id="valSensorX"></span> mm</label><br>
    <label>Sensor Y (lateral): <input id="sliderSensorY" type="range" min="-80" max="80" value="0" step="1"> <span id="valSensorY"></span> mm</label><br>
    <label>Alcance (mm): <input id="sliderSensorRange" type="range" min="100" max="1000" value="500" step="10"> <span id="valSensorRange"></span> mm</label><br>
    <label>FOV (°): <input id="sliderSensorFOV" type="range" min="5" max="90" value="30" step="1"> <span id="valSensorFOV"></span>°</label><br>
    <label>Masa total (g): <input id="sliderMasa" type="range" min="100" max="2000" value="400" step="10"> <span id="valMasa"></span> g</label><br>
    <label>Fricción ruedas: <input id="sliderFriccion" type="range" min="0.1" max="3" value="1.2" step="0.01"> <span id="valFriccion"></span></label><br>
    <label>Fuerza: <input id="sliderFuerza" type="range" min="0.0001" max="0.01" value="0.0005" step="0.0001"> <span id="valFuerza"></span></label><br>
    <label>Inercia: <input id="sliderInercia" type="range" min="100" max="100000" value="3700" step="100"> <span id="valInercia"></span></label><br>
    <label>Rozamiento angular: <input id="sliderRozamiento" type="range" min="0.7" max="1" value="0.96" step="0.01"> <span id="valRozamiento"></span></label><br>
    <label>Freno motor: <input id="sliderFreno" type="range" min="0" max="1" value="0.86" step="0.01"> <span id="valFreno"></span></label><br>
    <label>Distancia detección (mm): <input id="sliderDeteccion" type="range" min="50" max="500" value="200" step="1"> <span id="valDeteccion"></span> mm</label><br>
    <label>Ángulo sensor + (°): <input id="sliderAnguloPos" type="range" min="10" max="180" value="90" step="1"> <span id="valAnguloPos"></span>°</label><br>
    <label>Ángulo sensor - (°): <input id="sliderAnguloNeg" type="range" min="-180" max="-10" value="-90" step="1"> <span id="valAnguloNeg"></span>°</label><br>
    <label>Tiempo giro robot (ms): <input id="sliderTiempoGiro" type="range" min="100" max="2000" value="500" step="10"> <span id="valTiempoGiro"></span> ms</label><br>
  </div>
  <canvas id="sim"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
    // Configuración inicial
    const { Engine, World, Bodies, Body, Runner, Events } = Matter;
    const SCALE = 1; // 1px = 1mm
    const canvas = document.getElementById('sim');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Crear motor y mundo sin gravedad
    const engine = Engine.create();
    engine.gravity.y = 0;
    engine.gravity.x = 0;
    const world = engine.world;

    // Crear paredes de borde (3px de ancho)
    function createWalls() {
      const thickness = 3;
      const w = canvas.width;
      const h = canvas.height;
      const walls = [
        // Top
        Bodies.rectangle(w/2, thickness/2, w, thickness, { isStatic: true, label: 'wall' }),
        // Bottom
        Bodies.rectangle(w/2, h - thickness/2, w, thickness, { isStatic: true, label: 'wall' }),
        // Left
        Bodies.rectangle(thickness/2, h/2, thickness, h, { isStatic: true, label: 'wall' }),
        // Right
        Bodies.rectangle(w - thickness/2, h/2, thickness, h, { isStatic: true, label: 'wall' })
      ];
      World.add(world, walls);
    }
    createWalls();

    // Redibujar paredes si cambia el tamaño del canvas
    window.addEventListener('resize', () => {
      // Eliminar paredes anteriores
      World.clear(world, false);
      createWalls();
    });

    // Cargar imagen del chasis
    const chassisImg = new Image();
    chassisImg.src = 'Chassis3.png';

    // Dimensiones del chasis (en px = mm)
    const chassisWidth = 220; // px
    const chassisHeight = 151; // px

    // Dimensiones de la rueda
    const wheelWidth = 65; // px
    const wheelHeight = 27; // px

    // Cargar imagen de la rueda
    const wheelImg = new Image();
    wheelImg.src = 'robot_wheel.png';

    // Cargar imagen del sensor
    const sensorImg = new Image();
    sensorImg.src = 'sensor.png';
    // Dimensiones del sensor (aprox)
    const sensorWidth = 50; // px
    const sensorHeight = 32; // px

    // Sliders para offsets
    let wheelOffsetX = parseFloat(document.getElementById('sliderX').value); // será 25 por defecto
    let wheelOffsetY = parseFloat(document.getElementById('sliderY').value); // será 63 por defecto
    document.getElementById('valX').textContent = wheelOffsetX;
    document.getElementById('valY').textContent = wheelOffsetY;
    document.getElementById('sliderX').addEventListener('input', (e) => {
      wheelOffsetX = parseFloat(e.target.value);
      document.getElementById('valX').textContent = wheelOffsetX;
      updateWheelPositions();
    });
    document.getElementById('sliderY').addEventListener('input', (e) => {
      wheelOffsetY = parseFloat(e.target.value);
      document.getElementById('valY').textContent = wheelOffsetY;
      updateWheelPositions();
    });

    // Sliders para offsets del sensor
    let sensorOffsetX = parseFloat(document.getElementById('sliderSensorX').value); // 90 por defecto
    let sensorOffsetY = parseFloat(document.getElementById('sliderSensorY').value); // 0 por defecto
    document.getElementById('valSensorX').textContent = sensorOffsetX;
    document.getElementById('valSensorY').textContent = sensorOffsetY;
    document.getElementById('sliderSensorX').addEventListener('input', (e) => {
      sensorOffsetX = parseFloat(e.target.value);
      document.getElementById('valSensorX').textContent = sensorOffsetX;
    });
    document.getElementById('sliderSensorY').addEventListener('input', (e) => {
      sensorOffsetY = parseFloat(e.target.value);
      document.getElementById('valSensorY').textContent = sensorOffsetY;
    });

    // Sliders para alcance y FOV del sensor
    let sensorRange = parseFloat(document.getElementById('sliderSensorRange').value); // 500mm por defecto
    let sensorFOV = parseFloat(document.getElementById('sliderSensorFOV').value); // 30° por defecto
    document.getElementById('valSensorRange').textContent = sensorRange;
    document.getElementById('valSensorFOV').textContent = sensorFOV;
    document.getElementById('sliderSensorRange').addEventListener('input', (e) => {
      sensorRange = parseFloat(e.target.value);
      document.getElementById('valSensorRange').textContent = sensorRange;
    });
    document.getElementById('sliderSensorFOV').addEventListener('input', (e) => {
      sensorFOV = parseFloat(e.target.value);
      document.getElementById('valSensorFOV').textContent = sensorFOV;
    });

    // Sliders para masa total y fricción de ruedas
    let masaTotal = parseFloat(document.getElementById('sliderMasa').value) / 1000; // en kg
    let friccionRuedas = parseFloat(document.getElementById('sliderFriccion').value);
    document.getElementById('valMasa').textContent = masaTotal * 1000;
    document.getElementById('valFriccion').textContent = friccionRuedas;
    document.getElementById('sliderMasa').addEventListener('input', (e) => {
      masaTotal = parseFloat(e.target.value) / 1000;
      document.getElementById('valMasa').textContent = masaTotal * 1000;
      // 75% masa al chasis, 12.5% a cada rueda
      Body.setMass(chassis, masaTotal * 0.75);
      Body.setMass(leftWheel, masaTotal * 0.125);
      Body.setMass(rightWheel, masaTotal * 0.125);
    });
    document.getElementById('sliderFriccion').addEventListener('input', (e) => {
      friccionRuedas = parseFloat(e.target.value);
      document.getElementById('valFriccion').textContent = friccionRuedas;
      leftWheel.friction = friccionRuedas;
      rightWheel.friction = friccionRuedas;
      leftWheel.frictionStatic = friccionRuedas * 1.5;
      rightWheel.frictionStatic = friccionRuedas * 1.5;
      leftWheel.frictionAir = 0.01 + friccionRuedas * 0.01;
      rightWheel.frictionAir = 0.01 + friccionRuedas * 0.01;
    });

    // Sliders para fuerza, inercia y rozamiento angular
    let FORCE = parseFloat(document.getElementById('sliderFuerza').value);
    let inertiaValue = parseFloat(document.getElementById('sliderInercia').value);
    let angularFriction = parseFloat(document.getElementById('sliderRozamiento').value);
    document.getElementById('valFuerza').textContent = FORCE;
    document.getElementById('valInercia').textContent = inertiaValue;
    document.getElementById('valRozamiento').textContent = angularFriction;
    document.getElementById('sliderFuerza').addEventListener('input', (e) => {
      FORCE = parseFloat(e.target.value);
      document.getElementById('valFuerza').textContent = FORCE;
    });
    document.getElementById('sliderInercia').addEventListener('input', (e) => {
      inertiaValue = parseFloat(e.target.value);
      document.getElementById('valInercia').textContent = inertiaValue;
      Body.setInertia(robot, inertiaValue); // Asegura que el valor se aplique al robot
    });
    document.getElementById('sliderRozamiento').addEventListener('input', (e) => {
      angularFriction = parseFloat(e.target.value);
      document.getElementById('valRozamiento').textContent = angularFriction;
    });

    // Slider para freno motor
    let frenoMotor = parseFloat(document.getElementById('sliderFreno').value);
    document.getElementById('valFreno').textContent = frenoMotor;
    document.getElementById('sliderFreno').addEventListener('input', (e) => {
      frenoMotor = parseFloat(e.target.value);
      document.getElementById('valFreno').textContent = frenoMotor;
    });

    // Sliders para lógica autónoma
    let distanciaDeteccion = parseFloat(document.getElementById('sliderDeteccion').value);
    let anguloSensorPos = parseFloat(document.getElementById('sliderAnguloPos').value);
    let anguloSensorNeg = parseFloat(document.getElementById('sliderAnguloNeg').value);
    let tiempoGiroRobot = parseFloat(document.getElementById('sliderTiempoGiro').value);
    document.getElementById('valDeteccion').textContent = distanciaDeteccion;
    document.getElementById('valAnguloPos').textContent = anguloSensorPos;
    document.getElementById('valAnguloNeg').textContent = anguloSensorNeg;
    document.getElementById('valTiempoGiro').textContent = tiempoGiroRobot;
    document.getElementById('sliderDeteccion').addEventListener('input', (e) => {
      distanciaDeteccion = parseFloat(e.target.value);
      document.getElementById('valDeteccion').textContent = distanciaDeteccion;
    });
    document.getElementById('sliderAnguloPos').addEventListener('input', (e) => {
      anguloSensorPos = parseFloat(e.target.value);
      document.getElementById('valAnguloPos').textContent = anguloSensorPos;
    });
    document.getElementById('sliderAnguloNeg').addEventListener('input', (e) => {
      anguloSensorNeg = parseFloat(e.target.value);
      document.getElementById('valAnguloNeg').textContent = anguloSensorNeg;
    });
    document.getElementById('sliderTiempoGiro').addEventListener('input', (e) => {
      tiempoGiroRobot = parseFloat(e.target.value);
      document.getElementById('valTiempoGiro').textContent = tiempoGiroRobot;
    });

    // Crear cuerpos de las ruedas
    const leftWheel = Bodies.rectangle(
      canvas.width / 2 + wheelOffsetX,
      canvas.height / 2 + wheelOffsetY,
      wheelWidth,
      wheelHeight,
      {
        label: 'leftWheel',
        render: { visible: false },
        collisionFilter: { group: -1 },
        friction: friccionRuedas,
        frictionStatic: friccionRuedas * 1.5,
        frictionAir: 0.01 + friccionRuedas * 0.01,
        mass: masaTotal * 0.125
      }
    );
    const rightWheel = Bodies.rectangle(
      canvas.width / 2 + wheelOffsetX,
      canvas.height / 2 - wheelOffsetY,
      wheelWidth,
      wheelHeight,
      {
        label: 'rightWheel',
        render: { visible: false },
        collisionFilter: { group: -1 },
        friction: friccionRuedas,
        frictionStatic: friccionRuedas * 1.5,
        frictionAir: 0.01 + friccionRuedas * 0.01,
        mass: masaTotal * 0.125
      }
    );

    // Crear cuerpo del chasis
    const chassis = Bodies.rectangle(
      canvas.width / 2,
      canvas.height / 2,
      chassisWidth,
      chassisHeight,
      {
        label: 'chassis',
        render: { visible: false },
        collisionFilter: { group: -1 },
        mass: masaTotal * 0.75
      }
    );

    // Crear cuerpo compuesto del robot
    const robot = Body.create({
      parts: [chassis, leftWheel, rightWheel]
    });
    World.add(world, robot);
    // Aplicar inercia inicial del slider
    Body.setInertia(robot, inertiaValue);

    // Variables globales para debug de fuerzas
    let lastLeftForce = {pos: {x:0, y:0}, force: {x:0, y:0}};
    let lastRightForce = {pos: {x:0, y:0}, force: {x:0, y:0}};

    // Variables globales para debug de fricción lateral
    let lastLeftLateral = {pos: {x:0, y:0}, force: {x:0, y:0}};
    let lastRightLateral = {pos: {x:0, y:0}, force: {x:0, y:0}};

    let friccionLateral = 1.2; // Coeficiente de fricción lateral (ajustable, subido para notar efecto)

    // --- Fricción lateral en las ruedas ---
    function aplicarFriccionLateral() {
      // Para cada rueda (izquierda y derecha)
      [leftWheel, rightWheel].forEach((wheel, idx) => {
        // Ángulo del robot
        const ang = robot.angle;
        // Vector lateral local (eje Y local del robot)
        const lateralX = -Math.sin(ang);
        const lateralY = Math.cos(ang);
        // Velocidad de la rueda
        const vx = wheel.velocity.x;
        const vy = wheel.velocity.y;
        // Componente lateral de la velocidad
        const vLateral = vx * lateralX + vy * lateralY;
        // Fuerza de fricción lateral (opuesta a la velocidad lateral)
        const fuerzaLateral = -vLateral * wheel.mass * friccionLateral;
        // Aplicar fuerza en la dirección lateral
        const fuerza = {
          x: lateralX * fuerzaLateral,
          y: lateralY * fuerzaLateral
        };
        Body.applyForce(wheel, wheel.position, fuerza);
        // Guardar para graficar
        if (idx === 0) {
          lastLeftLateral = {pos: {...wheel.position}, force: {...fuerza}};
        } else {
          lastRightLateral = {pos: {...wheel.position}, force: {...fuerza}};
        }
      });
    }

    // Modifica applyWheelForces para guardar las fuerzas y posiciones
    function applyWheelForces(leftForce, rightForce) {
      // Calcular posiciones globales de las ruedas
      const cos = Math.cos(robot.angle);
      const sin = Math.sin(robot.angle);
      // Izquierda
      const leftPos = {
        x: robot.position.x + wheelOffsetX * cos + wheelOffsetY * sin,
        y: robot.position.y + wheelOffsetX * sin - wheelOffsetY * cos,
      };
      // Derecha
      const rightPos = {
        x: robot.position.x + wheelOffsetX * cos - wheelOffsetY * sin,
        y: robot.position.y + wheelOffsetX * sin + wheelOffsetY * cos,
      };
      // Aplicar fuerzas en la dirección del eje X local del robot
      const fx = Math.cos(robot.angle);
      const fy = Math.sin(robot.angle);
      const leftF = { x: leftForce * fx, y: leftForce * fy };
      const rightF = { x: rightForce * fx, y: rightForce * fy };
      Body.applyForce(robot, leftPos, leftF);
      Body.applyForce(robot, rightPos, rightF);
      // Guardar para debug
      lastLeftForce = {pos: {...leftPos}, force: {...leftF}};
      lastRightForce = {pos: {...rightPos}, force: {...rightF}};
    }

    // Gizmo para ejes locales
    function drawGizmo(ctx, x, y, angle, length = 60) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      // Eje X (rojo)
      ctx.strokeStyle = 'red';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(length, 0);
      ctx.stroke();
      // Eje Y (verde)
      ctx.strokeStyle = 'lime';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -length); // Y hacia arriba
      ctx.stroke();
      ctx.restore();
    }

    // Gizmo para ejes globales (esquina inferior izquierda)
    function drawWorldGizmo(ctx) {
      drawGizmo(ctx, 40, canvas.height - 40, 0, 40);
    }

    // Renderizado personalizado
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Dibujar paredes
      ctx.save();
      ctx.fillStyle = '#888';
      ctx.fillRect(0, 0, canvas.width, 3); // Top
      ctx.fillRect(0, canvas.height - 3, canvas.width, 3); // Bottom
      ctx.fillRect(0, 0, 3, canvas.height); // Left
      ctx.fillRect(canvas.width - 3, 0, 3, canvas.height); // Right
      ctx.restore();
      // Gizmo global
      drawWorldGizmo(ctx);
      // Renderizar robot (chasis y ruedas)
      ctx.save();
      ctx.translate(robot.position.x, robot.position.y);
      ctx.rotate(robot.angle);
      // Chasis
      ctx.drawImage(
        chassisImg,
        -chassisWidth / 2,
        -chassisHeight / 2,
        chassisWidth,
        chassisHeight
      );
      // Ruedas
      // Izquierda
      ctx.save();
      ctx.translate(wheelOffsetX, wheelOffsetY);
      ctx.drawImage(
        wheelImg,
        -wheelWidth / 2,
        -wheelHeight / 2,
        wheelWidth,
        wheelHeight
      );
      drawGizmo(ctx, 0, 0, 0, 30);
      ctx.restore();
      // Derecha
      ctx.save();
      ctx.translate(wheelOffsetX, -wheelOffsetY);
      ctx.drawImage(
        wheelImg,
        -wheelWidth / 2,
        -wheelHeight / 2,
        wheelWidth,
        wheelHeight
      );
      drawGizmo(ctx, 0, 0, 0, 30);
      ctx.restore();
      // Sensor ultrasónico
      ctx.save();
      ctx.translate(sensorOffsetX, sensorOffsetY);
      ctx.rotate(Math.PI/2 + sensorCurrentAngle); // Rotar +90 grados + animación
      // Zona de detección (FOV)
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = 'cyan';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      const fovRad = sensorFOV * Math.PI / 180;
      ctx.arc(0, 0, sensorRange, -fovRad/2 + Math.PI/2 + Math.PI, fovRad/2 + Math.PI/2 + Math.PI);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1.0;
      ctx.restore();
      ctx.drawImage(
        sensorImg,
        -sensorWidth / 2,
        -sensorHeight / 2,
        sensorWidth,
        sensorHeight
      );
      drawGizmo(ctx, 0, 0, 0, 30); // Gizmo local del sensor
      // Mostrar distancia medida como texto en la zona de detección
      // const dist = medirDistanciaSensor(sensorCurrentAngle);
      // ctx.save();
      // ctx.fillStyle = '#fff';
      // ctx.font = 'bold 18px sans-serif';
      // ctx.textAlign = 'center';
      // ctx.textBaseline = 'middle';
      // ctx.globalAlpha = 0.9;
      // ctx.fillText(Math.round(dist) + ' mm', 0, dist/2); // Eje Y positivo local
      // ctx.restore();
      ctx.restore();
      // Gizmo local del chasis
      drawGizmo(ctx, 0, 0, 0, 60);
      ctx.restore();

      // Dibujar fuerzas aplicadas (en coordenadas globales)
      drawForceArrow(ctx, lastLeftForce.pos.x, lastLeftForce.pos.y, lastLeftForce.force.x, lastLeftForce.force.y, 'magenta');
      drawForceArrow(ctx, lastRightForce.pos.x, lastRightForce.pos.y, lastRightForce.force.x, lastRightForce.force.y, 'yellow');

      // Dibujar fuerzas de fricción lateral
      drawForceArrow(ctx, lastLeftLateral.pos.x, lastLeftLateral.pos.y, lastLeftLateral.force.x, lastLeftLateral.force.y, 'blue');
      drawForceArrow(ctx, lastRightLateral.pos.x, lastRightLateral.pos.y, lastRightLateral.force.x, lastRightLateral.force.y, 'blue');
    }

    // --- Controles de teclado para movimiento tipo tanque ---
    let leftPower = 0;
    let rightPower = 0;

    window.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowUp':
          leftPower = FORCE;
          rightPower = FORCE;
          break;
        case 'ArrowDown':
          leftPower = -FORCE;
          rightPower = -FORCE;
          break;
        case 'ArrowLeft':
          leftPower = -FORCE;
          rightPower = FORCE;
          break;
        case 'ArrowRight':
          leftPower = FORCE;
          rightPower = -FORCE;
          break;
      }
    });
    window.addEventListener('keyup', (e) => {
      switch (e.key) {
        case 'ArrowUp':
        case 'ArrowDown':
        case 'ArrowLeft':
        case 'ArrowRight':
          leftPower = 0;
          rightPower = 0;
          break;
      }
    });

    // Rozamiento angular para evitar patinaje excesivo
    let eventsAdded = false;
    function addFriction() {
      if (eventsAdded) return;
      Events.on(engine, 'beforeUpdate', function() {
        // Rozamiento angular
        robot.angularVelocity *= angularFriction;
        // Freno motor: si no hay fuerza en las ruedas, frena casi instantáneamente
        if (leftPower === 0 && rightPower === 0) {
          Body.setAngularVelocity(robot, robot.angularVelocity * frenoMotor); // Freno angular configurable
          Body.setVelocity(robot, { 
            x: robot.velocity.x * frenoMotor, 
            y: robot.velocity.y * frenoMotor 
          }); // Freno lineal configurable
        }
        // Rozamiento lineal (opcional, descomentar si quieres más realismo)
        // robot.velocity.x *= 0.995;
        // robot.velocity.y *= 0.995;

        aplicarFriccionLateral(); // Fricción lateral en cada frame
      });
      eventsAdded = true;
    }
    addFriction();

    // Función para actualizar la posición de las ruedas en el cuerpo compuesto
    function updateWheelPositions() {
      // Actualiza la posición relativa de las partes en el cuerpo compuesto
      // (Matter.js no soporta mover partes, así que las movemos respecto al centro del robot)
      Body.setPosition(leftWheel, {
        x: robot.position.x + wheelOffsetX * Math.cos(robot.angle) + wheelOffsetY * Math.sin(robot.angle),
        y: robot.position.y + wheelOffsetX * Math.sin(robot.angle) - wheelOffsetY * Math.cos(robot.angle)
      });
      Body.setPosition(rightWheel, {
        x: robot.position.x + wheelOffsetX * Math.cos(robot.angle) - wheelOffsetY * Math.sin(robot.angle),
        y: robot.position.y + wheelOffsetX * Math.sin(robot.angle) + wheelOffsetY * Math.cos(robot.angle)
      });
    }
    // Llamar al inicio para asegurar posiciones correctas
    updateWheelPositions();

    // --- Lógica autónoma del robot ---
    function logicaAutonoma() {
      switch (estadoRobot) {
        case 'avanzando': {
          // Medir distancia al frente
          const dist = medirDistanciaSensor(sensorCurrentAngle);
          if (dist < distanciaDeteccion) {
            leftPower = 0;
            rightPower = 0;
            estadoRobot = 'giraSensorPos';
            sensorTargetAngle = anguloSensorPos * Math.PI / 180;
          } else {
            leftPower = FORCE;
            rightPower = FORCE;
          }
          break;
        }
        case 'giraSensorPos': {
          // Animar sensor hacia el ángulo positivo
          if (Math.abs(sensorCurrentAngle - sensorTargetAngle) > 0.01) {
            sensorCurrentAngle += Math.sign(sensorTargetAngle - sensorCurrentAngle) * sensorAnimSpeed;
          } else {
            sensorCurrentAngle = sensorTargetAngle;
            distanciaMedidaPos = medirDistanciaSensor(sensorCurrentAngle);
            estadoRobot = 'giraSensorNeg';
            sensorTargetAngle = anguloSensorNeg * Math.PI / 180;
          }
          leftPower = 0;
          rightPower = 0;
          break;
        }
        case 'giraSensorNeg': {
          // Animar sensor hacia el ángulo negativo
          if (Math.abs(sensorCurrentAngle - sensorTargetAngle) > 0.01) {
            sensorCurrentAngle += Math.sign(sensorTargetAngle - sensorCurrentAngle) * sensorAnimSpeed;
          } else {
            sensorCurrentAngle = sensorTargetAngle;
            distanciaMedidaNeg = medirDistanciaSensor(sensorCurrentAngle);
            // Guardar decisión de giro
            if (distanciaMedidaPos > distanciaMedidaNeg) {
              giroDerecha = true;
            } else {
              giroDerecha = false;
            }
            sensorTargetAngle = 0; // Volver a centro antes de girar
            estadoRobot = 'centraSensorAntesDeGiro';
          }
          leftPower = 0;
          rightPower = 0;
          break;
        }
        case 'centraSensorAntesDeGiro': {
          // Centrar el sensor antes de girar el robot
          if (Math.abs(sensorCurrentAngle) > 0.01) {
            sensorCurrentAngle += Math.sign(0 - sensorCurrentAngle) * sensorAnimSpeed;
            leftPower = 0;
            rightPower = 0;
          } else {
            sensorCurrentAngle = 0;
            estadoRobot = 'giraRobot';
            tiempoGiroRestante = tiempoGiroRobot;
            // Usar la decisión guardada
            if (giroDerecha) {
              leftPower = FORCE;
              rightPower = -FORCE;
            } else {
              leftPower = -FORCE;
              rightPower = FORCE;
            }
          }
          break;
        }
        case 'giraRobot': {
          // Girar el robot durante el tiempo configurado
          if (tiempoGiroRestante > 0) {
            tiempoGiroRestante -= 1000/60; // asumiendo 60 FPS
          } else {
            leftPower = 0;
            rightPower = 0;
            estadoRobot = 'centraSensor';
          }
          break;
        }
        case 'centraSensor': {
          // Animar sensor de vuelta al centro
          if (Math.abs(sensorCurrentAngle) > 0.01) {
            sensorCurrentAngle += Math.sign(0 - sensorCurrentAngle) * sensorAnimSpeed;
          } else {
            sensorCurrentAngle = 0;
            estadoRobot = 'avanzando';
          }
          leftPower = 0;
          rightPower = 0;
          break;
        }
      }
    }

    // --- Loop de simulación y renderizado ---
    const runner = Runner.create();
    function loop() {
      if (modoAutonomo) logicaAutonoma();
      applyWheelForces(leftPower, rightPower);
      Engine.update(engine, 1000 / 60);
      updateWheelPositions();
      render();
      requestAnimationFrame(loop);
    }

    // Esperar a que ambas imágenes estén cargadas
    let imagesLoaded = 0;
    function checkLoaded() {
      imagesLoaded++;
      if (imagesLoaded === 3) loop();
    }
    chassisImg.onload = checkLoaded;
    wheelImg.onload = checkLoaded;
    sensorImg.onload = checkLoaded;

    // Dibuja una flecha desde (x,y) en la dirección de (fx,fy)
    function drawForceArrow(ctx, x, y, fx, fy, color = 'cyan') {
      const scale = 1e5; // Escala visual de la flecha
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + fx * scale, y + fy * scale);
      ctx.stroke();
      // Flecha
      const angle = Math.atan2(fy, fx);
      ctx.beginPath();
      ctx.moveTo(x + fx * scale, y + fy * scale);
      ctx.lineTo(x + fx * scale - 10 * Math.cos(angle - 0.3), y + fy * scale - 10 * Math.sin(angle - 0.3));
      ctx.lineTo(x + fx * scale - 10 * Math.cos(angle + 0.3), y + fy * scale - 10 * Math.sin(angle + 0.3));
      ctx.lineTo(x + fx * scale, y + fy * scale);
      ctx.fill();
      ctx.restore();
    }

    // Variables de estado para lógica autónoma
    let modoAutonomo = true; // true para activar lógica autónoma
    let estadoRobot = 'avanzando'; // 'avanzando', 'detenido', 'giraSensorPos', 'giraSensorNeg', 'giraRobot', 'espera'
    let sensorTargetAngle = 0; // ángulo objetivo del sensor (en radianes)
    let sensorCurrentAngle = 0; // ángulo actual del sensor (en radianes)
    let sensorAnimSpeed = Math.PI / 60; // velocidad de animación del sensor (rads/frame)
    let distanciaMedidaPos = null;
    let distanciaMedidaNeg = null;
    let tiempoGiroRestante = 0;
    let giroDerecha = true; // Variable global para decisión de giro

    // --- Raycasting para el sensor ultrasónico ---
    function medirDistanciaSensor(sensorAngleRad) {
      // Posición global del sensor
      const cosR = Math.cos(robot.angle);
      const sinR = Math.sin(robot.angle);
      const sensorX = robot.position.x + sensorOffsetX * cosR + sensorOffsetY * sinR;
      const sensorY = robot.position.y + sensorOffsetX * sinR - sensorOffsetY * cosR;
      // Ángulo global del sensor (robot.angle + sensorCurrentAngle)
      const ang = robot.angle + sensorAngleRad; // Eje X positivo local, hacia adelante
      const dx = Math.cos(ang);
      const dy = Math.sin(ang);
      // Raycast: avanzar en pasos pequeños hasta chocar con una pared
      let dist = 0;
      let hit = false;
      const maxDist = sensorRange;
      const step = 2; // px
      while (dist < maxDist && !hit) {
        const px = sensorX + dx * dist;
        const py = sensorY + dy * dist;
        // Checar si está fuera del canvas (pared)
        if (px < 3 || px > canvas.width - 3 || py < 3 || py > canvas.height - 3) {
          hit = true;
          break;
        }
        dist += step;
      }
      return dist;
    }
  </script>
</body>
</html>