<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Simulación Matter.js Cenital</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #fff; /* Fondo blanco */
    }
    #sim {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #fff; /* Fondo blanco */
    }
  </style>
</head>
<body>
  <canvas id="sim"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
    // Configuración inicial
    const { Engine, World, Bodies, Body, Runner, Events } = Matter;
    const SCALE = 1; // 1px = 1mm
    const canvas = document.getElementById('sim');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Crear motor y mundo sin gravedad
    const engine = Engine.create();
    engine.gravity.y = 0;
    engine.gravity.x = 0;
    const world = engine.world;

    // Crear paredes de borde (3px de ancho)
    function createWalls() {
      const thickness = 3;
      const w = canvas.width;
      const h = canvas.height;
      const walls = [
        // Top
        Bodies.rectangle(w/2, thickness/2, w, thickness, { isStatic: true, label: 'wall' }),
        // Bottom
        Bodies.rectangle(w/2, h - thickness/2, w, thickness, { isStatic: true, label: 'wall' }),
        // Left
        Bodies.rectangle(thickness/2, h/2, thickness, h, { isStatic: true, label: 'wall' }),
        // Right
        Bodies.rectangle(w - thickness/2, h/2, thickness, h, { isStatic: true, label: 'wall' })
      ];
      World.add(world, walls);
    }
    createWalls();

    // Redibujar paredes si cambia el tamaño del canvas
    window.addEventListener('resize', () => {
      // Eliminar paredes anteriores
      World.clear(world, false);
      createWalls();
    });

    // Cargar imagen del chasis
    const chassisImg = new Image();
    chassisImg.src = 'Chassis3.png';

    // Dimensiones del chasis (en px = mm)
    const chassisWidth = 220; // px
    const chassisHeight = 151; // px

    // Dimensiones de la rueda
    const wheelWidth = 65; // px
    const wheelHeight = 27; // px

    // Cargar imagen de la rueda
    const wheelImg = new Image();
    wheelImg.src = 'robot_wheel.png';

    // Cargar imagen del sensor
    const sensorImg = new Image();
    sensorImg.src = 'sensor.png';
    // Dimensiones del sensor (aprox)
    const sensorWidth = 50; // px
    const sensorHeight = 32; // px

    // --- Valores fijos (antes dependían de sliders) ---
    let wheelOffsetX = 25;
    let wheelOffsetY = 63;
    let sensorOffsetX = 90;
    let sensorOffsetY = 0;
    let sensorRange = 500;
    let sensorFOV = 30;
    let masaTotal = 420 / 1000; // en kg
    let friccionRuedas = 1.2;
    let FORCE = 0.0001;
    let inertiaValue = 6400;
    let angularFriction = 0.96;
    let frenoMotor = 0.14;
    let distanciaDeteccion = 200;
    let anguloSensorPos = 90;
    let anguloSensorNeg = -90;
    let tiempoGiroRobot = 1010;
    // --- Fin valores fijos ---

    // --- Robot 1 ---
    // Posición y ángulo aleatorios para robot 1
    function randomRobotPose() {
      const margin = 100;
      const x = margin + Math.random() * (canvas.width - 2 * margin);
      const y = margin + Math.random() * (canvas.height - 2 * margin);
      const angle = Math.random() * 2 * Math.PI;
      return { x, y, angle };
    }
    const pose1 = randomRobotPose();
    const pose2 = randomRobotPose();

    const leftWheel = Bodies.rectangle(
      pose1.x + wheelOffsetX,
      pose1.y + wheelOffsetY,
      wheelWidth,
      wheelHeight,
      {
        label: 'leftWheel',
        render: { visible: false },
        collisionFilter: { group: -1 },
        friction: friccionRuedas,
        frictionStatic: friccionRuedas * 1.5,
        frictionAir: 0.01 + friccionRuedas * 0.01,
        mass: masaTotal * 0.125
      }
    );
    const rightWheel = Bodies.rectangle(
      pose1.x + wheelOffsetX,
      pose1.y - wheelOffsetY,
      wheelWidth,
      wheelHeight,
      {
        label: 'rightWheel',
        render: { visible: false },
        collisionFilter: { group: -1 },
        friction: friccionRuedas,
        frictionStatic: friccionRuedas * 1.5,
        frictionAir: 0.01 + friccionRuedas * 0.01,
        mass: masaTotal * 0.125
      }
    );
    const chassis = Bodies.rectangle(
      pose1.x,
      pose1.y,
      chassisWidth,
      chassisHeight,
      {
        label: 'chassis',
        render: { visible: false },
        collisionFilter: { group: -1 },
        mass: masaTotal * 0.75
      }
    );
    const robot = Body.create({
      parts: [chassis, leftWheel, rightWheel]
    });
    Body.setAngle(robot, pose1.angle);
    World.add(world, robot);
    Body.setInertia(robot, inertiaValue);

    // --- Robot 2 ---
    const leftWheel2 = Bodies.rectangle(
      pose2.x + wheelOffsetX,
      pose2.y + wheelOffsetY,
      wheelWidth,
      wheelHeight,
      {
        label: 'leftWheel2',
        render: { visible: false },
        collisionFilter: { group: -2 },
        friction: friccionRuedas,
        frictionStatic: friccionRuedas * 1.5,
        frictionAir: 0.01 + friccionRuedas * 0.01,
        mass: masaTotal * 0.125
      }
    );
    const rightWheel2 = Bodies.rectangle(
      pose2.x + wheelOffsetX,
      pose2.y - wheelOffsetY,
      wheelWidth,
      wheelHeight,
      {
        label: 'rightWheel2',
        render: { visible: false },
        collisionFilter: { group: -2 },
        friction: friccionRuedas,
        frictionStatic: friccionRuedas * 1.5,
        frictionAir: 0.01 + friccionRuedas * 0.01,
        mass: masaTotal * 0.125
      }
    );
    const chassis2 = Bodies.rectangle(
      pose2.x,
      pose2.y,
      chassisWidth,
      chassisHeight,
      {
        label: 'chassis2',
        render: { visible: false },
        collisionFilter: { group: -2 },
        mass: masaTotal * 0.75
      }
    );
    const robot2 = Body.create({
      parts: [chassis2, leftWheel2, rightWheel2]
    });
    Body.setAngle(robot2, pose2.angle);
    World.add(world, robot2);
    Body.setInertia(robot2, inertiaValue);

    let friccionLateral = 1.2; // Coeficiente de fricción lateral (ajustable, subido para notar efecto)

    // --- Fricción lateral en las ruedas ---
    function aplicarFriccionLateral() {
      [leftWheel, rightWheel].forEach((wheel) => {
        const ang = robot.angle;
        const lateralX = -Math.sin(ang);
        const lateralY = Math.cos(ang);
        const vx = wheel.velocity.x;
        const vy = wheel.velocity.y;
        const vLateral = vx * lateralX + vy * lateralY;
        const fuerzaLateral = -vLateral * wheel.mass * friccionLateral;
        const fuerza = {
          x: lateralX * fuerzaLateral,
          y: lateralY * fuerzaLateral
        };
        Body.applyForce(wheel, wheel.position, fuerza);
      });
    }

    function aplicarFriccionLateral2() {
      [leftWheel2, rightWheel2].forEach((wheel) => {
        const ang = robot2.angle;
        const lateralX = -Math.sin(ang);
        const lateralY = Math.cos(ang);
        const vx = wheel.velocity.x;
        const vy = wheel.velocity.y;
        const vLateral = vx * lateralX + vy * lateralY;
        const fuerzaLateral = -vLateral * wheel.mass * friccionLateral;
        const fuerza = {
          x: lateralX * fuerzaLateral,
          y: lateralY * fuerzaLateral
        };
        Body.applyForce(wheel, wheel.position, fuerza);
      });
    }

    // Modifica applyWheelForces para guardar las fuerzas y posiciones
    function applyWheelForces(leftForce, rightForce) {
      const cos = Math.cos(robot.angle);
      const sin = Math.sin(robot.angle);
      const leftPos = {
        x: robot.position.x + wheelOffsetX * cos + wheelOffsetY * sin,
        y: robot.position.y + wheelOffsetX * sin - wheelOffsetY * cos,
      };
      const rightPos = {
        x: robot.position.x + wheelOffsetX * cos - wheelOffsetY * sin,
        y: robot.position.y + wheelOffsetX * sin + wheelOffsetY * cos,
      };
      const fx = Math.cos(robot.angle);
      const fy = Math.sin(robot.angle);
      const leftF = { x: leftForce * fx, y: leftForce * fy };
      const rightF = { x: rightForce * fx, y: rightForce * fy };
      Body.applyForce(robot, leftPos, leftF);
      Body.applyForce(robot, rightPos, rightF);
    }

    function applyWheelForces2(leftForce, rightForce) {
      const cos = Math.cos(robot2.angle);
      const sin = Math.sin(robot2.angle);
      const leftPos = {
        x: robot2.position.x + wheelOffsetX * cos + wheelOffsetY * sin,
        y: robot2.position.y + wheelOffsetX * sin - wheelOffsetY * cos,
      };
      const rightPos = {
        x: robot2.position.x + wheelOffsetX * cos - wheelOffsetY * sin,
        y: robot2.position.y + wheelOffsetX * sin + wheelOffsetY * cos,
      };
      const fx = Math.cos(robot2.angle);
      const fy = Math.sin(robot2.angle);
      const leftF = { x: leftForce * fx, y: leftForce * fy };
      const rightF = { x: rightForce * fx, y: rightForce * fy };
      Body.applyForce(robot2, leftPos, leftF);
      Body.applyForce(robot2, rightPos, rightF);
    }

    // Renderizado personalizado
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.fillStyle = 'rgba(120,120,120,0.12)'; // Paredes muy transparentes
      ctx.fillRect(0, 0, canvas.width, 3); // Top
      ctx.fillRect(0, canvas.height - 3, canvas.width, 3); // Bottom
      ctx.fillRect(0, 0, 3, canvas.height); // Left
      ctx.fillRect(canvas.width - 3, 0, 3, canvas.height); // Right
      ctx.restore();

      // --- Robot 1 ---
      ctx.save();
      ctx.translate(robot.position.x, robot.position.y);
      ctx.rotate(robot.angle);
      ctx.drawImage(
        chassisImg,
        -chassisWidth / 2,
        -chassisHeight / 2,
        chassisWidth,
        chassisHeight
      );
      ctx.save();
      ctx.translate(wheelOffsetX, wheelOffsetY);
      ctx.drawImage(
        wheelImg,
        -wheelWidth / 2,
        -wheelHeight / 2,
        wheelWidth,
        wheelHeight
      );
      ctx.restore();
      ctx.save();
      ctx.translate(wheelOffsetX, -wheelOffsetY);
      ctx.drawImage(
        wheelImg,
        -wheelWidth / 2,
        -wheelHeight / 2,
        wheelWidth,
        wheelHeight
      );
      ctx.restore();
      ctx.save();
      ctx.translate(sensorOffsetX, sensorOffsetY);
      ctx.rotate(Math.PI/2 + sensorCurrentAngle);
      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = 'rgba(200,200,200,0.18)'; // Gris muy claro y transparente
      ctx.beginPath();
      ctx.moveTo(0, 0);
      const fovRad = sensorFOV * Math.PI / 180;
      ctx.arc(0, 0, sensorRange, -fovRad/2 + Math.PI/2 + Math.PI, fovRad/2 + Math.PI/2 + Math.PI);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      ctx.drawImage(
        sensorImg,
        -sensorWidth / 2,
        -sensorHeight / 2,
        sensorWidth,
        sensorHeight
      );
      ctx.restore();
      ctx.restore();

      // --- Robot 2 ---
      ctx.save();
      ctx.translate(robot2.position.x, robot2.position.y);
      ctx.rotate(robot2.angle);
      ctx.drawImage(
        chassisImg,
        -chassisWidth / 2,
        -chassisHeight / 2,
        chassisWidth,
        chassisHeight
      );
      ctx.save();
      ctx.translate(wheelOffsetX, wheelOffsetY);
      ctx.drawImage(
        wheelImg,
        -wheelWidth / 2,
        -wheelHeight / 2,
        wheelWidth,
        wheelHeight
      );
      ctx.restore();
      ctx.save();
      ctx.translate(wheelOffsetX, -wheelOffsetY);
      ctx.drawImage(
        wheelImg,
        -wheelWidth / 2,
        -wheelHeight / 2,
        wheelWidth,
        wheelHeight
      );
      ctx.restore();
      ctx.save();
      ctx.translate(sensorOffsetX, sensorOffsetY);
      ctx.rotate(Math.PI/2 + sensorCurrentAngle2);
      ctx.save();
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = 'rgba(200,200,200,0.18)'; // Gris muy claro y transparente
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, sensorRange, -fovRad/2 + Math.PI/2 + Math.PI, fovRad/2 + Math.PI/2 + Math.PI);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      ctx.drawImage(
        sensorImg,
        -sensorWidth / 2,
        -sensorHeight / 2,
        sensorWidth,
        sensorHeight
      );
      ctx.restore();
      ctx.restore();
    }

    // --- Controles de teclado para movimiento tipo tanque ---
    let leftPower = 0;
    let rightPower = 0;
    let leftPower2 = 0;
    let rightPower2 = 0;

    function fuerzaConVariacion(base) {
      const variacion = 0.55;
      const factor = 1 + (Math.random() * 2 - 1) * variacion;
      return base * factor;
    }

    window.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowUp':
          leftPower = fuerzaConVariacion(FORCE);
          rightPower = fuerzaConVariacion(FORCE);
          break;
        case 'ArrowDown':
          leftPower = fuerzaConVariacion(-FORCE);
          rightPower = fuerzaConVariacion(-FORCE);
          break;
        case 'ArrowLeft':
          leftPower = fuerzaConVariacion(-FORCE);
          rightPower = fuerzaConVariacion(FORCE);
          break;
        case 'ArrowRight':
          leftPower = fuerzaConVariacion(FORCE);
          rightPower = fuerzaConVariacion(-FORCE);
          break;
      }
    });
    window.addEventListener('keyup', (e) => {
      switch (e.key) {
        case 'ArrowUp':
        case 'ArrowDown':
        case 'ArrowLeft':
        case 'ArrowRight':
          leftPower = 0;
          rightPower = 0;
          break;
      }
    });

    let eventsAdded = false;
    function addFriction() {
      if (eventsAdded) return;
      Events.on(engine, 'beforeUpdate', function() {
        robot.angularVelocity *= angularFriction;
        robot2.angularVelocity *= angularFriction;
        if (leftPower === 0 && rightPower === 0) {
          Body.setAngularVelocity(robot, robot.angularVelocity * frenoMotor);
          Body.setVelocity(robot, { x: robot.velocity.x * frenoMotor, y: robot.velocity.y * frenoMotor });
        }
        if (leftPower2 === 0 && rightPower2 === 0) {
          Body.setAngularVelocity(robot2, robot2.angularVelocity * frenoMotor);
          Body.setVelocity(robot2, { x: robot2.velocity.x * frenoMotor, y: robot2.velocity.y * frenoMotor });
        }
        aplicarFriccionLateral();
        aplicarFriccionLateral2();
      });
      eventsAdded = true;
    }
    addFriction();

    function updateWheelPositions() {
      Body.setPosition(leftWheel, {
        x: robot.position.x + wheelOffsetX * Math.cos(robot.angle) + wheelOffsetY * Math.sin(robot.angle),
        y: robot.position.y + wheelOffsetX * Math.sin(robot.angle) - wheelOffsetY * Math.cos(robot.angle)
      });
      Body.setPosition(rightWheel, {
        x: robot.position.x + wheelOffsetX * Math.cos(robot.angle) - wheelOffsetY * Math.sin(robot.angle),
        y: robot.position.y + wheelOffsetX * Math.sin(robot.angle) + wheelOffsetY * Math.cos(robot.angle)
      });
    }

    function updateWheelPositions2() {
      Body.setPosition(leftWheel2, {
        x: robot2.position.x + wheelOffsetX * Math.cos(robot2.angle) + wheelOffsetY * Math.sin(robot2.angle),
        y: robot2.position.y + wheelOffsetX * Math.sin(robot2.angle) - wheelOffsetY * Math.cos(robot2.angle)
      });
      Body.setPosition(rightWheel2, {
        x: robot2.position.x + wheelOffsetX * Math.cos(robot2.angle) - wheelOffsetY * Math.sin(robot2.angle),
        y: robot2.position.y + wheelOffsetX * Math.sin(robot2.angle) + wheelOffsetY * Math.cos(robot2.angle)
      });
    }
    updateWheelPositions();
    updateWheelPositions2();

    // --- Lógica autónoma del robot ---
    let modoAutonomo = true;
    let estadoRobot = 'avanzando';
    let sensorTargetAngle = 0;
    let sensorCurrentAngle = 0;
    let sensorAnimSpeed = Math.PI / 60;
    let distanciaMedidaPos = null;
    let distanciaMedidaNeg = null;
    let tiempoGiroRestante = 0;
    let giroDerecha = true;

    function logicaAutonoma() {
      switch (estadoRobot) {
        case 'avanzando': {
          const dist = medirDistanciaSensor(sensorCurrentAngle);
          if (dist < distanciaDeteccion) {
            leftPower = 0;
            rightPower = 0;
            estadoRobot = 'giraSensorPos';
            sensorTargetAngle = anguloSensorPos * Math.PI / 180;
          } else {
            leftPower = fuerzaConVariacion(FORCE);
            rightPower = fuerzaConVariacion(FORCE);
          }
          break;
        }
        case 'giraSensorPos': {
          if (Math.abs(sensorCurrentAngle - sensorTargetAngle) > 0.01) {
            sensorCurrentAngle += Math.sign(sensorTargetAngle - sensorCurrentAngle) * sensorAnimSpeed;
          } else {
            sensorCurrentAngle = sensorTargetAngle;
            distanciaMedidaPos = medirDistanciaSensor(sensorCurrentAngle);
            estadoRobot = 'giraSensorNeg';
            sensorTargetAngle = anguloSensorNeg * Math.PI / 180;
          }
          leftPower = 0;
          rightPower = 0;
          break;
        }
        case 'giraSensorNeg': {
          if (Math.abs(sensorCurrentAngle - sensorTargetAngle) > 0.01) {
            sensorCurrentAngle += Math.sign(sensorTargetAngle - sensorCurrentAngle) * sensorAnimSpeed;
          } else {
            sensorCurrentAngle = sensorTargetAngle;
            distanciaMedidaNeg = medirDistanciaSensor(sensorCurrentAngle);
            if (distanciaMedidaPos > distanciaMedidaNeg) {
              giroDerecha = true;
            } else {
              giroDerecha = false;
            }
            sensorTargetAngle = 0;
            estadoRobot = 'centraSensorAntesDeGiro';
          }
          leftPower = 0;
          rightPower = 0;
          break;
        }
        case 'centraSensorAntesDeGiro': {
          if (Math.abs(sensorCurrentAngle) > 0.01) {
            sensorCurrentAngle += Math.sign(0 - sensorCurrentAngle) * sensorAnimSpeed;
            leftPower = 0;
            rightPower = 0;
          } else {
            sensorCurrentAngle = 0;
            estadoRobot = 'giraRobot';
            tiempoGiroRestante = tiempoGiroRobot;
            if (giroDerecha) {
              leftPower = fuerzaConVariacion(FORCE);
              rightPower = fuerzaConVariacion(-FORCE);
            } else {
              leftPower = fuerzaConVariacion(-FORCE);
              rightPower = fuerzaConVariacion(FORCE);
            }
          }
          break;
        }
        case 'giraRobot': {
          if (tiempoGiroRestante > 0) {
            tiempoGiroRestante -= 1000/60;
          } else {
            leftPower = 0;
            rightPower = 0;
            estadoRobot = 'centraSensor';
          }
          break;
        }
        case 'centraSensor': {
          if (Math.abs(sensorCurrentAngle) > 0.01) {
            sensorCurrentAngle += Math.sign(0 - sensorCurrentAngle) * sensorAnimSpeed;
          } else {
            sensorCurrentAngle = 0;
            estadoRobot = 'avanzando';
          }
          leftPower = 0;
          rightPower = 0;
          break;
        }
      }
    }

    // --- Lógica autónoma del robot 2 ---
    let modoAutonomo2 = true;
    let estadoRobot2 = 'avanzando';
    let sensorTargetAngle2 = 0;
    let sensorCurrentAngle2 = 0;
    let distanciaMedidaPos2 = null;
    let distanciaMedidaNeg2 = null;
    let tiempoGiroRestante2 = 0;
    let giroDerecha2 = true;

    function logicaAutonoma2() {
      switch (estadoRobot2) {
        case 'avanzando': {
          const dist = medirDistanciaSensor2(sensorCurrentAngle2);
          if (dist < distanciaDeteccion) {
            leftPower2 = 0;
            rightPower2 = 0;
            estadoRobot2 = 'giraSensorPos';
            sensorTargetAngle2 = anguloSensorPos * Math.PI / 180;
          } else {
            leftPower2 = fuerzaConVariacion(FORCE);
            rightPower2 = fuerzaConVariacion(FORCE);
          }
          break;
        }
        case 'giraSensorPos': {
          if (Math.abs(sensorCurrentAngle2 - sensorTargetAngle2) > 0.01) {
            sensorCurrentAngle2 += Math.sign(sensorTargetAngle2 - sensorCurrentAngle2) * sensorAnimSpeed;
          } else {
            sensorCurrentAngle2 = sensorTargetAngle2;
            distanciaMedidaPos2 = medirDistanciaSensor2(sensorCurrentAngle2);
            estadoRobot2 = 'giraSensorNeg';
            sensorTargetAngle2 = anguloSensorNeg * Math.PI / 180;
          }
          leftPower2 = 0;
          rightPower2 = 0;
          break;
        }
        case 'giraSensorNeg': {
          if (Math.abs(sensorCurrentAngle2 - sensorTargetAngle2) > 0.01) {
            sensorCurrentAngle2 += Math.sign(sensorTargetAngle2 - sensorCurrentAngle2) * sensorAnimSpeed;
          } else {
            sensorCurrentAngle2 = sensorTargetAngle2;
            distanciaMedidaNeg2 = medirDistanciaSensor2(sensorCurrentAngle2);
            if (distanciaMedidaPos2 > distanciaMedidaNeg2) {
              giroDerecha2 = true;
            } else {
              giroDerecha2 = false;
            }
            sensorTargetAngle2 = 0;
            estadoRobot2 = 'centraSensorAntesDeGiro';
          }
          leftPower2 = 0;
          rightPower2 = 0;
          break;
        }
        case 'centraSensorAntesDeGiro': {
          if (Math.abs(sensorCurrentAngle2) > 0.01) {
            sensorCurrentAngle2 += Math.sign(0 - sensorCurrentAngle2) * sensorAnimSpeed;
            leftPower2 = 0;
            rightPower2 = 0;
          } else {
            sensorCurrentAngle2 = 0;
            estadoRobot2 = 'giraRobot';
            tiempoGiroRestante2 = tiempoGiroRobot;
            if (giroDerecha2) {
              leftPower2 = fuerzaConVariacion(FORCE);
              rightPower2 = fuerzaConVariacion(-FORCE);
            } else {
              leftPower2 = fuerzaConVariacion(-FORCE);
              rightPower2 = fuerzaConVariacion(FORCE);
            }
          }
          break;
        }
        case 'giraRobot': {
          if (tiempoGiroRestante2 > 0) {
            tiempoGiroRestante2 -= 1000/60;
          } else {
            leftPower2 = 0;
            rightPower2 = 0;
            estadoRobot2 = 'centraSensor';
          }
          break;
        }
        case 'centraSensor': {
          if (Math.abs(sensorCurrentAngle2) > 0.01) {
            sensorCurrentAngle2 += Math.sign(0 - sensorCurrentAngle2) * sensorAnimSpeed;
          } else {
            sensorCurrentAngle2 = 0;
            estadoRobot2 = 'avanzando';
          }
          leftPower2 = 0;
          rightPower2 = 0;
          break;
        }
      }
    }

    // --- Loop de simulación y renderizado ---
    const runner = Runner.create();
    function loop() {
      if (modoAutonomo) logicaAutonoma();
      if (modoAutonomo2) logicaAutonoma2();
      applyWheelForces(leftPower, rightPower);
      applyWheelForces2(leftPower2, rightPower2);
      Engine.update(engine, 1000 / 60);
      updateWheelPositions();
      updateWheelPositions2();
      render();
      requestAnimationFrame(loop);
    }

    // Esperar a que ambas imágenes estén cargadas
    let imagesLoaded = 0;
    function checkLoaded() {
      imagesLoaded++;
      if (imagesLoaded === 3) loop();
    }
    chassisImg.onload = checkLoaded;
    wheelImg.onload = checkLoaded;
    sensorImg.onload = checkLoaded;

    // --- Raycasting para el sensor ultrasónico ---
    function medirDistanciaSensor(sensorAngleRad) {
      const cosR = Math.cos(robot.angle);
      const sinR = Math.sin(robot.angle);
      const sensorX = robot.position.x + sensorOffsetX * cosR + sensorOffsetY * sinR;
      const sensorY = robot.position.y + sensorOffsetX * sinR - sensorOffsetY * cosR;
      const ang = robot.angle + sensorAngleRad;
      const dx = Math.cos(ang);
      const dy = Math.sin(ang);
      let dist = 0;
      let hit = false;
      const maxDist = sensorRange;
      const step = 2;
      while (dist < maxDist && !hit) {
        const px = sensorX + dx * dist;
        const py = sensorY + dy * dist;
        // Detectar paredes
        if (px < 3 || px > canvas.width - 3 || py < 3 || py > canvas.height - 3) {
          hit = true;
          break;
        }
        // Detectar robot2 (chasis2)
        if (
          px > chassis2.position.x - chassisWidth/2 && px < chassis2.position.x + chassisWidth/2 &&
          py > chassis2.position.y - chassisHeight/2 && py < chassis2.position.y + chassisHeight/2
        ) {
          hit = true;
          break;
        }
        dist += step;
      }
      return dist;
    }

    // --- Raycasting para el sensor ultrasónico del robot 2 ---
    function medirDistanciaSensor2(sensorAngleRad) {
      const cosR = Math.cos(robot2.angle);
      const sinR = Math.sin(robot2.angle);
      const sensorX = robot2.position.x + sensorOffsetX * cosR + sensorOffsetY * sinR;
      const sensorY = robot2.position.y + sensorOffsetX * sinR - sensorOffsetY * cosR;
      const ang = robot2.angle + sensorAngleRad;
      const dx = Math.cos(ang);
      const dy = Math.sin(ang);
      let dist = 0;
      let hit = false;
      const maxDist = sensorRange;
      const step = 2;
      while (dist < maxDist && !hit) {
        const px = sensorX + dx * dist;
        const py = sensorY + dy * dist;
        // Detectar paredes
        if (px < 3 || px > canvas.width - 3 || py < 3 || py > canvas.height - 3) {
          hit = true;
          break;
        }
        // Detectar robot1 (chasis)
        if (
          px > chassis.position.x - chassisWidth/2 && px < chassis.position.x + chassisWidth/2 &&
          py > chassis.position.y - chassisHeight/2 && py < chassis.position.y + chassisHeight/2
        ) {
          hit = true;
          break;
        }
        dist += step;
      }
      return dist;
    }
  </script>
</body>
</html>